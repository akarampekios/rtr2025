#version 460 core
#extension GL_EXT_ray_tracing : require

struct RayPayload {
    vec3 color;
    vec3 normal;
    vec3 worldPos;
    float hitDistance;
    int bounceCount;
};

layout(location = 0) rayPayloadEXT RayPayload payload;
layout(set = 0, binding = 0, rgba8) uniform image2D outputImage;
layout(set = 0, binding = 1) uniform accelerationStructureEXT topLevelAS;

layout(set = 0, binding = 2) uniform CameraUBO {
    mat4 viewInverse;
    mat4 projInverse;
    vec3 cameraPos;
    float time;
} cameraUBO;

layout(set = 0, binding = 3) uniform LightingUBO {
    vec3 lightPositions[4];
    vec3 lightColors[4];
    float lightIntensities[4];
    int lightCount;
    vec3 ambientLight;
    float exposure;
} lighting;

// Volumetric fog function
vec3 calculateVolumetricFog(vec3 rayOrigin, vec3 rayDirection, float rayDistance) {
    vec3 fogColor = vec3(0.1, 0.05, 0.2); // Dark purple fog
    float fogDensity = 0.02;
    float fogHeight = 20.0; // Height where fog starts
    
    vec3 accumulatedFog = vec3(0.0);
    float stepSize = 2.0;
    int steps = int(rayDistance / stepSize);
    
    for (int i = 0; i < steps; i++) {
        float t = float(i) * stepSize;
        vec3 samplePos = rayOrigin + rayDirection * t;
        
        // Height-based fog density
        float heightFactor = exp(-max(0.0, samplePos.y - fogHeight) * 0.1);
        float localDensity = fogDensity * heightFactor;
        
        // Add some noise for atmospheric variation
        float noise = sin(samplePos.x * 0.1) * cos(samplePos.z * 0.1) * 0.5 + 0.5;
        localDensity *= (0.8 + noise * 0.4);
        
        // Accumulate fog
        float fogAmount = 1.0 - exp(-localDensity * stepSize);
        accumulatedFog += fogColor * fogAmount * (1.0 - length(accumulatedFog));
    }
    
    return accumulatedFog;
}

// Function to trace a ray and return the result
RayPayload traceRay(vec3 origin, vec3 direction, int maxBounces) {
    RayPayload result;
    result.color = vec3(0.0);
    result.normal = vec3(0.0, 1.0, 0.0);
    result.worldPos = origin;
    result.hitDistance = 0.0;
    result.bounceCount = 0;
    
    vec3 currentOrigin = origin;
    vec3 currentDirection = direction;
    vec3 accumulatedColor = vec3(0.0);
    float accumulatedAttenuation = 1.0;
    
    for (int bounce = 0; bounce < maxBounces; bounce++) {
        payload = result;
        
        traceRayEXT(topLevelAS,
                    gl_RayFlagsTerminateOnFirstHitEXT,
                    0xFF,
                    0,
                    0,
                    0,
                    currentOrigin,
                    0.001,
                    currentDirection,
                    10000.0,
                    0);
        
        result = payload;
        
        if (result.hitDistance > 0.0) {
            // Ray hit something
            vec3 hitColor = result.color;
            vec3 hitNormal = result.normal;
            vec3 hitPos = result.worldPos;
            
            // Calculate lighting at hit point
            vec3 finalColor = vec3(0.0);
            
            // Ambient lighting
            finalColor += hitColor * lighting.ambientLight;
            
            // Direct lighting from all lights
            for (int i = 0; i < lighting.lightCount; i++) {
                vec3 lightDir = normalize(lighting.lightPositions[i] - hitPos);
                float lightDistance = length(lighting.lightPositions[i] - hitPos);
                float attenuation = 1.0 / (1.0 + 0.1 * lightDistance + 0.01 * lightDistance * lightDistance);
                
                // Simple diffuse lighting
                float NdotL = max(dot(hitNormal, lightDir), 0.0);
                vec3 diffuse = hitColor * lighting.lightColors[i] * lighting.lightIntensities[i] * NdotL * attenuation;
                finalColor += diffuse;
                
                // Add some specular highlights for cyberpunk feel
                vec3 viewDir = normalize(cameraUBO.cameraPos - hitPos);
                vec3 reflectDir = reflect(-lightDir, hitNormal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                vec3 specular = lighting.lightColors[i] * lighting.lightIntensities[i] * spec * attenuation * 0.5;
                finalColor += specular;
            }
            
            // Add volumetric fog between camera and hit point
            vec3 fog = calculateVolumetricFog(currentOrigin, currentDirection, result.hitDistance);
            finalColor = mix(finalColor, fog, 0.3);
            
            accumulatedColor += finalColor * accumulatedAttenuation;
            
            // For reflections (simplified)
            if (bounce < maxBounces - 1) {
                currentOrigin = hitPos + hitNormal * 0.001;
                currentDirection = reflect(currentDirection, hitNormal);
                accumulatedAttenuation *= 0.7; // Reflection attenuation
            }
        } else {
            // Ray missed - use sky color with atmospheric effects
            vec3 skyColor = vec3(0.05, 0.1, 0.2) + vec3(0.1, 0.05, 0.3) * sin(cameraUBO.time * 0.5);
            
            // Add distant fog
            vec3 distantFog = calculateVolumetricFog(currentOrigin, currentDirection, 1000.0);
            skyColor = mix(skyColor, distantFog, 0.5);
            
            accumulatedColor += skyColor * accumulatedAttenuation;
            break;
        }
    }
    
    result.color = accumulatedColor;
    return result;
}

void main() {
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    const vec2 d = inUV * 2.0 - 1.0;

    vec4 clip = vec4(d, 1.0, 1.0);
    vec4 viewDir = cameraUBO.projInverse * clip;
    viewDir /= viewDir.w;

    vec3 worldOrigin = cameraUBO.cameraPos;
    vec3 worldDirection = normalize((cameraUBO.viewInverse * vec4(viewDir.xyz, 0.0)).xyz);

    RayPayload result = traceRay(worldOrigin, worldDirection, 2);
    vec3 finalColor = result.color;

    finalColor = vec3(1.0) - exp(-finalColor * lighting.exposure);

    // Write shaded color; use DEBUG_PAYLOAD to override inside hit shaders if needed
    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1.0));
}
